---
title: Silent Cartographer (WIP)
authors: David Aghassi, Jonathan Lee, Lucas Shadler
date: 10/27/2021
demo: https://github.com/Aghassi/bazel-module-federation 
---

# Bazel Federated SPA

This document aims to outline the ideas for a way to scale large scale monolith websites in a way that solves a majority of the problems that exist today in the frontend development space. The ideas will be backed by an example repository to prove out the overall architecture.

## Problem

As companies grow, they hit a limit where they must decide whether to trade off a single page application with a single slow build process for multiple smaller apps with faster build processes (but more complexity because each app now requires its own maintenance and upgrades). A single build process ensures the apps get updated at once, especially when it comes to shared libraries. Multiple apps don’t have this advantage, but multiple apps do allow for rolling upgrades so that different libraries can be upgraded independently across the codebases. At scale, this rolling upgrade tends to tie up teams into “continuous migrations”, which prevents them from doing meaningful feature work and improvements on the libraries.

## Solution

The solution being designed is aimed at the use case of development within a monorepo. This is because it allows for both fast builds (given the right tooling) as well as collocation of 1st party dependencies (thus removing half of the versioning problem with the assumption that they build from HEAD).

Given a monorepo with a web application, the application can be split into four distinct parts:

- Bazel - built directed acyclic graph that has a defined package for each part of the application (allowing for build granularity as well as a dependency graph in code)
- cartographer - (also known as the “host” in webpack terminology) that serves to bootstrap the application as well as define a common set of shared dependencies. Intrinsically, this package depends on the routes to make sure it reads the proper hash information generated by each route’s built output.
- roads - routes defined in a “routes” folder following the paradigm of route/NAME/index.tsx (where NAME is the name of the route the cartographer will utilize to map to the road). These “routes” are known as “remotes” in webpack terminology. Each road would expose a single entry point to the cartographer, but also depends on the cartographer for bootstrapping changes. Due to this contract, roads need to be integration tested when changes to the cartographer occur. However, roads can be developed in isolation from the cartographer.
  - As a safety, roads cannot depend on other roads as that would cause complexity in the DAG. Shared code is best split out into first part dependencies
  - To iterate on the prior point, shared components can go into a design system which is shared amongst the roads for simplicity.
  - Roads are built with Webpack but using ESBuild-loader instead of babel and ESBuild for optimization instead of terser
  - Context for each road should be a mapping based on the folder structure of the initial source files. This will allow us to design clients, services, and CDNs that can reliably fetch road contexts and interact with the road artifacts.
    - Example: a routes folder contains two things
      - folders with the name of routes
      - an index file at the root of the folder that defines the `/` route
    - Each folder and root index file maps to an object, further discussed in the `API Design` section
    - The manifest is hydrated by the server and exposed to the host (cartographer) to know what to load when each route is navigated to
server - A lightweight nodejs container that is responsible for constructing the HTML markup to be sent to a user when they request the website. The server has access to:
The CDN url
a file that maps all paths to their roads with the hash embedded in the file name (this file will be prefixed by the CDN for lookup)
the known location and hash of the cartographer

Since we would leverage Module Federation, it alleviates the problem of single version upgrades. Roads can upgrade ahead of the rest of the app if there is a circumstance where they want to run ahead. In general, the app can move in lockstep as well as purposefully leave roads behind if they are blocking an upgrade of the rest of the app. This allows flexibility at scale, and can be enforced and tracked by other tools to drive version alignment. The performance hit of not upgrading is usually good enough to encourage folks to upgrade and follow paradigms.

With these three distinct parts defined, let’s take a scenario to prove out this solution:

> An application has four roads that are part of the host application managed by the cartographer. If a single road is changed, that road and the cartographer rebuild thanks to the graph defined by Bazel. All routes unchanged are considered cache hits and thus are not rebuilt. The output of the single road rebuild is used as input into the cartographer. The cartographer avoids a rebuild assuming we have a step under Bazel that generates a lookup file that can be read from the server. The file has the new hash embedded and the set of artifacts is then lined up for release to the CDN to be loaded via a backend node service that is aware of the new cartographer.

In all cases, we should only rebuild the roads that are being actively developed. By separating the lookup map from the cartographer build (and instead giving it a string of code) we can disconnect the cartographer from rebuilds when the roads are rebuilt.

To ensure we cover our bases when releasing, the final artifact (container of the server with proper hash lookups) should go through integration testing and validation against important user flows before being certified for a release.

## API Design

<!-- TODO: Image here of diagram -->

We design a manifest object for the cartographer that defines the location of the entry file for each route within it's context:

```json
{
    "/": "index.[sha].js",
    "/login": "login-index.[sha].js"
}
```

In the above, we assume that `[sha]` will represent a content-bashed hash of the file, which provides the ability to have long-lived caching mechanisms for each entry file.

Should we anticipate multiple builds of the project, then we should define for each route a flat mapping of "bundle identifier."

```json
{
    "/": {
        "en-us-es6": "index.a.[sha].js",
        "en-us-node": "index.b.[sha].js",
        "default": "index.c.[sha].js"
    },
    "/login": {
        "en-us-es6": "login-index.a.[sha].js",
        "en-us-node": "login-index.b.[sha].js",
        "default": "login-index.c.[sha].js"
    },
}
```

We assume that the application would have the ability to calculate a suitable build identifier for a given route. For the client, this can be done via DOM context and simple ES testing. For the server, this can be a function of the useragent and the request headers. Note that `default` would act as a fallback to the case that no identifier could be adequately selected.

## Beyond the Proof of Concept

After a successful POC, we anticipate we will have the following:

- A way to develop individual routes in isolation without requiring a rebuild of different routes
- A service and client runtime that can load federated routes 
- A portable docker container that will facilitate the application

In the following sections, we will discuss options and features that will be the next things to target.

### Supporting multiple bundles per route

It is relatively common that an application will need to target different languages as their project scales to meet the needs of users across the globe. This targeting could also be extended to technology, where based on the client browser, a different subset of JavaScript features will be supported. When a browser doesn’t support a given feature, we typically “polyfill” the browser with the implementation we need, at the cost of needing more JavaScript to be delivered to the client.

Performance on the web, amongst many other factors, is dependent on the amount of content required to be fetched by a clients machine in order to render an application. If we can support multiple builds of a given route that minimize the amount of polyfilled content, and also preemptively localize each bundle with the appropriate language, then our users would see noticeable benefit.

The building of these multiple routes will be facilitated through Bazel, which can call Webpack multiple times for a given route. This defers the build caching to Bazel, which will do a better job only building routes whose dependencies change compared to Webpack multi-builds. The value of this would be very noticeable, as localization tools typically have small  changes to subsets of the languages they support over time, which would thus only change a portion of the builds.

The main hurdle here is in reconciling configurations for multiple builds, given that we want all routes to have a content-hashed entry file for client-side caching. In general, we need:

- A flat config structure that can provide a mapping from route to any arbitrary number of builds, plus a default build
- The ability for a cartographer to select a given route based on its context (potentially delivered by the server via useragent and request headers, but not required)
- Developer tooling: ability to select which language to load in a developer context to easily validate different builds 
- Developer tooling: integration testing against each build (Bazel should already enforce this with DAG)

### Eager Routes (and SSR)

In our first iteration, all routes will be dynamically loaded on the client side. However, it would be advantageous to consider the ability to preemptively load and/or render these dynamic routes for cases where performance is a hard requirement. The ability to statically render HTML is very necessary for marketing pages, where performance can heavily impact SEO and, by proxy, business goals.
